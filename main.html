<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script defer src="https://unpkg.com/p5.collide2d"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
    <script>
          function start(){
		// number of rows
        const nrows = Math.floor(innerHeight / 45) - 6;
		// number of columns
		const ncols = Math.floor(innerWidth / 45) - 1;
		// user
		const cat = `<img src="https://i.imgur.com/e9LJtL4.png" height="27px" width="27px"></img>`;
		// goal
		const burger = `<img src="https://i.imgur.com/GugJK1Z.png" height="27px" width="27px"></img>`;

		function createCells() {
			for (let i = 0; i < nrows; i++) {
				// creates cell element
				let row = document.createElement("div");
				// adds it to a list
				row.classList.add("row");
			// makes first row
			if (i === 0) row.classList.add("first-row");
			// adds row to the body
			document.body.appendChild(row);

			// same thing as rows but for columns
			for (let j = 0; j < ncols; j++) {
				let col = document.createElement("div");
				col.classList.add("cell");
			if (j === 0) col.classList.add("first-col");
				row.appendChild(col);
			}
		}
	}

createCells();

class Cell {
	constructor(i, j) {
		this.r = i;
		this.c = j;

		this.neighbors = [];
		this.walls = [true, true, true, true]; //Top Right Bottom Left
		this.visited = false;
	}
	show() {
		// walls of the cells
		if (!this.walls[0])
			cellElements[this.r * ncols + this.c].style["border-top"] = "none";
		if (!this.walls[1])
			cellElements[this.r * ncols + this.c].style["border-right"] = "none";
		if (!this.walls[2])
			cellElements[this.r * ncols + this.c].style["border-bottom"] = "none";
		if (!this.walls[3])
			cellElements[this.r * ncols + this.c].style["border-left"] = "none";

		// chages color of cells that are done
		if (this.visited)
			cellElements[this.r * ncols + this.c].style.background = "greenyellow";
	}
	// keeps the mae generator within the border
	createNeighbors() {
		if (this.r > 0) this.neighbors.push(grid[(this.r - 1) * ncols + this.c]); //Top
		if (this.c < ncols - 1)
			this.neighbors.push(grid[this.r * ncols + (this.c + 1)]); //Right
		if (this.r < nrows - 1)
			this.neighbors.push(grid[(this.r + 1) * ncols + this.c]); //Bottom
		if (this.c > 0) this.neighbors.push(grid[this.r * ncols + (this.c - 1)]); //Left
	}
	fix() {
		if (!this.walls[1] && !this.walls[2])
			cellElements[this.r * ncols + this.c].classList.add("bottomRightCorner");
	}
}

// adds cells to the grid tha the user sees
function fillGrid() {
	for (let i = 0; i < nrows; i++) {
		for (let j = 0; j < ncols; j++) {
			grid.push(new Cell(i, j));
		}
	}
	for (let i = 0; i < nrows; i++) {
		for (let j = 0; j < ncols; j++) {
			grid[i * ncols + j].createNeighbors();
		}
	}
}

let cellElements = document.querySelectorAll(".cell");
let grid = [];
fillGrid();

let current = grid[0];
let stack = [];
let play = false;
let goal = grid[nrows * ncols - 1];
let drawLoop = setInterval(animate, 50);
let canAnimate = true;
let popUps = [];

//Algorithm based on how mazes work
function BacktrackingDFS() {
	cellElements[current.r * ncols + current.c].style.background = "olive";
// make sure all cells are visited
	if (!current.visited) {
		current.visited = true;
		stack.push(current);
	}

	let unvisited = [];
	for (let neigh of current.neighbors) {
		if (!neigh.visited) {
			unvisited.push(neigh);
		}
	}

	if (unvisited.length > 0) {
		let randomIndex = Math.floor(Math.random() * unvisited.length);
		let next = unvisited[randomIndex];

		//Remove Walls
		if (current.r - next.r === 1) {
			//TOP
			current.walls[0] = false;
			next.walls[2] = false;
		} else if (current.c - next.c === -1) {
			//RIGHT
			current.walls[1] = false;
			next.walls[3] = false;
		} else if (current.r - next.r === -1) {
			//BOTTOM
			current.walls[2] = false;
			next.walls[0] = false;
		} else if (current.c - next.c === 1) {
			//LEFT
			current.walls[3] = false;
			next.walls[1] = false;
		}

		current = next;
	} else if (stack.length > 0) {
		current = stack.pop();
	} else {
		clearInterval(drawLoop);
		play = true;
		cellElements[current.r * ncols + current.c].style.background = "greenyellow";
		cellElements[goal.r * ncols + goal.c].innerHTML = burger;
		cellElements[current.r * ncols + current.c].innerHTML = cat;
	}
}

// user end
function animate() {
	for (let i = 0; i < nrows; i++) {
		for (let j = 0; j < ncols; j++) {
			grid[i * ncols + j].show();
		}
	}
	for (let i = 0; i < nrows; i++) {
		for (let j = 0; j < ncols; j++) {
			grid[i * ncols + j].fix();
		}
	}
	BacktrackingDFS();
}

// GAME PLAY PHASE BEGINS HERE
let btn = document.querySelector(".generate-maze");
btn.addEventListener("click", function () {
	clearInterval(drawLoop);
	for (let popUp of popUps) {
		popUp.style.display = "none";
	}
	for (let i = 0; i < nrows; i++) {
		for (let j = 0; j < ncols; j++) {
			cellElements[i * ncols + j].removeAttribute("style");
			cellElements[i * ncols + j].classList.remove("bottomRightCorner");
			cellElements[i * ncols + j].innerHTML = "";
		}
	}
	grid = [];
	fillGrid();
	current = grid[0];
	stack = [];
	play = false;
	goal = grid[nrows * ncols - 1];
	if (canAnimate) drawLoop = setInterval(animate, 50);
	else {
		while (!play) {
			animate();
		}
	}
});

let directionButtons = document.querySelectorAll(".direction-button");


// onscreen controls
// for (let k = 0; k < directionButtons.length; k++) {
// 	directionButtons[k].addEventListener("mousedown", function () {
// 		if (play) {
// 			cellElements[current.r * ncols + current.c].innerHTML = ``;
// 			if (k == 0) upArrowPressed();
// 			if (k == 1) leftArrowPressed();
// 			if (k == 2) rightArrowPressed();
// 			if (k == 3) downArrowPressed();
// 			cellElements[current.r * ncols + current.c].innerHTML = cat;
// 			checkWin();
// 		}
// 	});
// }
// keyboard controls
document.body.addEventListener("keydown", function (event) {
	if (play) {
		cellElements[current.r * ncols + current.c].innerHTML = ``;
		if (event.key === "ArrowUp") upArrowPressed();
		if (event.key === "ArrowLeft") leftArrowPressed();
		if (event.key === "ArrowRight") rightArrowPressed();
		if (event.key === "ArrowDown") downArrowPressed();
		cellElements[current.r * ncols + current.c].innerHTML = cat;
		checkWin();
	}
});

document.body.addEventListener("keyup", function (event) {
	for (let k = 0; k < directionButtons.length; k++) {
		directionButtons[k].classList.remove("highlight");
	}
});

document.body.addEventListener("mouseup", function (event) {
	for (let k = 0; k < directionButtons.length; k++) {
		directionButtons[k].classList.remove("highlight");
	}
});

function checkWin() {
	if (current === goal) {
		console.log("WON");
		play = false;
		victoryMessage();
	}
}

// base controls
function upArrowPressed() {
	if (!current.walls[0]) current = grid[(current.r - 1) * ncols + current.c];
	directionButtons[0].classList.add("highlight");
}
function leftArrowPressed() {
	if (!current.walls[3]) current = grid[current.r * ncols + (current.c - 1)];
	directionButtons[1].classList.add("highlight");
}
function rightArrowPressed() {
	if (!current.walls[1]) current = grid[current.r * ncols + (current.c + 1)];
	directionButtons[2].classList.add("highlight");
}
function downArrowPressed() {
	if (!current.walls[2]) current = grid[(current.r + 1) * ncols + current.c];
	directionButtons[3].classList.add("highlight");
}

function victoryMessage() {
	popUps = [];
	for (let i = 0; i < 10; i++) {
		const popUp = document.createElement("span");
		popUp.classList.add("heart");
		popUp.innerHTML = `<i class="fas fa-heart"></i>`;

		popUp.style.top = Math.random() * 50 + 50 + "%";
		popUp.style.left = Math.random() * 100 + "%";
		popUp.style.fontSize = Math.random() * 10 + 5 + "px";

		popUps.push(popUp);
	}

	for (let i = 0; i < 10; i++) {
		setTimeout(function () {
			cellElements[(goal.r - 1) * ncols + goal.c].appendChild(popUps[i]);
			setTimeout(function () {
				popUps[i].remove();
			}, 2000);
		}, i * 100);
	}
}
          }
    </script>
</body>
</html>
